package cc.unknown.module.impl.exploit;

import java.util.HashMap;
import java.util.Map;

import cc.unknown.event.Listener;
import cc.unknown.event.annotations.EventLink;
import cc.unknown.event.impl.netty.PacketReceiveEvent;
import cc.unknown.event.impl.netty.PacketSendEvent;
import cc.unknown.event.impl.player.PreMotionEvent;
import cc.unknown.module.Module;
import cc.unknown.module.api.Category;
import cc.unknown.module.api.ModuleInfo;
import cc.unknown.util.packet.PacketUtil;
import cc.unknown.util.packet.process.IncomingPackets;
import cc.unknown.util.packet.process.OutgoingPackets;
import cc.unknown.value.impl.BooleanValue;
import cc.unknown.value.impl.ModeValue;
import cc.unknown.value.impl.SubMode;
import net.minecraft.network.Packet;
import net.minecraft.network.play.INetHandlerPlayClient;
import net.minecraft.network.play.INetHandlerPlayServer;

@ModuleInfo(aliases = "Custom Disabler", description = "Desactiva parcialmente los anticheats.", category = Category.EXPLOIT)
public class CustomDisabler extends Module {
    
    private final ModeValue packetMode = new ModeValue("Packet Mode", this)
            .add(new SubMode("Outgoing"))
            .add(new SubMode("Incoming"))
            .setDefault("Outgoing");
    
    private final ModeValue mode = new ModeValue("Mode", this)
            .add(new SubMode("Cancel"))
            .add(new SubMode("Send"))
            .setDefault("Send");
    
    private final Map<Class<? extends Packet<?>>, BooleanValue> packetSettings = new HashMap<>();

    public CustomDisabler() {
        for (Class<? extends Packet<INetHandlerPlayServer>> packet : OutgoingPackets.getOutgoingPackets()) {
            packetSettings.put(packet, new BooleanValue(packet.getSimpleName(), this, false, () -> !packetMode.is("Outgoing")));
        }
        
        for (Class<? extends Packet<INetHandlerPlayClient>> packet : IncomingPackets.getIncomingPackets()) {
            packetSettings.put(packet, new BooleanValue(packet.getSimpleName(), this, false, () -> !packetMode.is("Incoming")));
        }
    }

    @EventLink
    public final Listener<PacketSendEvent> onSend = event -> {
        if (shouldCancelPacket(event.getPacket(), packetMode.is("Outgoing"))) {
            event.setCancelled(true);
        }
    };

    @EventLink
    public final Listener<PacketReceiveEvent> onReceive = event -> {
        if (shouldCancelPacket(event.getPacket(), packetMode.is("Incoming"))) {
            event.setCancelled(true);
        }
    };
    
    @EventLink
    public final Listener<PreMotionEvent> onPreMotion = event -> {
        if (mode.is("Send")) {
            processPackets();
        }
    };
    
    private void processPackets() {
        for (Class<? extends Packet<?>> packetClass : packetSettings.keySet()) {
            BooleanValue setting = packetSettings.get(packetClass);
            if (setting != null && setting.getValue()) {
                Packet packet = packetInstance(packetClass);
                if (packet != null) {
                    if (packetMode.is("Outgoing")) {
                        PacketUtil.sendNoEvent(packet);
                    } else if (packetMode.is("Incoming")) {
                        PacketUtil.receiveNoEvent(packet);
                    }
                }
            }
        }
    }
    
    private boolean shouldCancelPacket(Packet<?> packet, boolean isOutgoing) {
        if (mode.is("Cancel")) {
            BooleanValue setting = packetSettings.get(packet.getClass());
            return setting != null && setting.getValue() && isOutgoing;
        }
        return false;
    }

    private Packet packetInstance(Class<? extends Packet<?>> packetClass) {
        try {
            return packetClass.getConstructor().newInstance();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
}